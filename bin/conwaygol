#!/bin/bash

LANG=C

pname="$(basename "$0")"
stime=$(date +%Y%m%d%H%M%S)
tmp=/tmp/"$pname"."$stime".$$

trap 'rm -f $tmp-*' EXIT

######################################################################

pattern=${1:-"-"}

X=${2:-"10"}
Y=${3:-"10"}

######################################################################

mkfifo $tmp-base

tr '\0' '0'	< /dev/zero	|
    fold -w $((X + 2))		|
    head -n $((Y + 2))	> $tmp-base	&

# shape X x Y size
## == narrow $X $Y 0 0
awk -v FS='' -v X="$X" -v Y="$Y"	'
	NR > Y	{
		print "'"$pname.$stime.$$[$LINENO]INFO : cell row overflow, choped."'"	> "/dev/stderr";
		exit 0;
	}
	(length() > X)	{
		print "'"$pname.$stime.$$[$LINENO]INFO : cell colmun overflow, choped."'"	> "/dev/stderr";
	}
	{	print substr($0,1,'"$X"')	}'	$pattern	|
    # == ido 1 1
    awk -v FS='' -v X="$X" -v Y="$Y"	'
	BEGIN{	print	}
	{	print " " $0 }'						|
    # translate
    tr '0 _' 0		|
    tr -c '0 _\n' 1	|
    # == overlay $tmp-base -
    paste -d'\0' $tmp-base -						|
    awk -v FS='' -v X="$X" -v Y="$Y"	'
	BEGIN{	o = X + 2; }
	((l = length()) == X)	{
		print ; next ;	}
	{	print substr($0,o+1,l-o) substr($0,l-o+1,2 * o-l)
		next ;	}'						|
    #
    # {{ foldcell
    # == overwrap 3
    awk -v W=3	'
	{	i = (NR % W) ; l[i] = $0 ;	}
	NR >= W{
		o = l[(i+1) % W]
		for(j=1;j<W;j++)	{
			o = o " " l[(i+j+1) % W]
		}
		print o
	}'								|
    # bind 9 cells into 1 cell
    tr -d ' '								|
    awk -v FS="" -v X="$X" -v Y="$Y"	'
	BEGIN{	o = X + 2; }
	{	for(i=1;i<=X;i++)	{
			l = ""					# clear
			l = l $(i)     $(i+1)     $(i+2)	# upper cell
			l = l $(o+i)   $(o+i+1)   $(o+i+2)	# middle cell
			l = l $(2*o+i) $(2*o+i+1) $(2*o+i+2)	# lower cell

			print l
		}
	}'									|
    # foldcell }}
    # # the output is one cell per one line
    #
    # apply rules
    awk -v FS="" -v X="$X" -v Y="$Y"	'
	{	n = 0;
		for(i=1;i<=9;i++)	{	n += $(i)	}

		if($5 == 0)	{	# dead cell
			# RULE1 : reproduction
			if(n == 3)				{	print "X";	}
			else					{	print "_";	}
		} else {	# living cell
			# RULE2 : sustain
			if(n == (2 + 1) || n == (3 + 1))	{	print "X";	}
			# RULE3 : underpopulation
			else if (n <= (1 + 1))			{	print "_";	}
			# RULE4 : overpopulation
			else if (n >= (4 + 1))			{	print "_";	}
			# unreachable
			else	{
				print "'"$pname.$stime.$$[$LINENO]ERROR : unreachable code section."'"	> "/dev/stderr";
				exit 1;
			}
		}
	}'		|
    tr -d '\n'		|
    {
	cat
	echo
    }			|
    fold -w "$X"

######################################################################
exit 0
